function [CP,S] = cp_wrapper(filename, isDiscrete, test, Crit, fig)% % [CP,S]=cp_wrapper(filename,isDiscrete, test, Crit, fig)%% cp wrapper is used to combine the relevant functions for the changepoint% algorithim into a single easy-to-use function. It returns an array (CP)% giving the coordinates of the significant change points in the cumulative% record and a vector (S) giving the slopes of the cumulative record between% change points. It graphs the cumulative record, with the change points% indicated, and below that the slopes between the change points. I%% The first argument (the name of the file or variable containing the data) % is obligatory; it must be specified when the function is called.% if the remaining three arguments are not supplied when the function is called,% the user will be prompted for them. % If the first argument is a file to read data from, put single quotes around it.% The file must be a tab-delimited ASCII file,% with one datum per line, and with the .txt extension. If the first% argument is a variable in a Matlab workspace, it must be a column vector. In% either case, the data should be in uncumulated form (trial-by-trial% measurements, or successive interevent intervals).%% Valid parameter values:%   isDiscrete: 0 or 1%     1 for discrete-trial data and 0 for successive real-valued intervals%       (e.g., the intervals between successive events or the distances%       between successive landmarks)%   test: 1, 2, 3 or 4%     1 for binomial (random rate) - must be integer-valued when used in%        discrete-trials case%     2 for Kolmogorov-Smirnov (real- or integer-valued data, although%        technically only valid for real-valued variables)%     3 for t test (either integer- or real-valued data)%     4 for chisquare test (must be binary data - 0 or 1 in each row)% %   Crit: A critical value use to test the significance of a given change point%    Values should generally be in the range between 1.3, which corresponds to%    a p value of .05 and 6, which corresponds to a p value of .000001%%   fig - optional 5th argument; to suppress figures, set to falseif nargin<2    isDiscrete=input('Are these discrete-trial measurements? (1 if yes; 0 if no) ');    test=input('What test should be used to compare data before and after a putative change point? \n (Answer 1 for binomial, 2 for K-S, 3 for t test or 4 for chi square) ');    Crit=input('Logit value (decision criterion between 1.3 and 6)? ');endif nargin < 5 % fig argument not specified in call    fig = true; % defaultend%setupif ischar(filename)    Data  = load(filename);else    Data=filename;end% consistency checksif (isDiscrete==0) && (test==4)    disp('Cannot use chi square test when data are successive intervals')    returnendif (test==4) && (sum(Data+~Data)~=length(Data))    disp('When chi square test is used, data must be binary, i.e. 0 or 1')    returnendif (isDiscrete==1) && (test==1) && (~isequal(mod(Data,ones(size(Data))),zeros(size(Data))))    disp('When the binomial test is used with discrete-trial data, the data must be integer valued')    returnendCum=cumsum(Data); % the cumulative record% Section for computing CP array when binomial (random rate) test is used% or when chi square test is usedif (test==1) || (test==4)       Cumt=Cum; % Initializiing for while loop. The Cumt vector will    % be truncated as change points are found        if test==1 % if binomial test is to be used        CritLength=1; % When binomial test is used, there must be at least two data    else        CritLength=7; % A test of differences of frequency cannot be significant when        % the total number of observations is less than 8    end    CP=[0 0]; r=1; % Initializing for while loop        while (~isempty(r) && (length(Cumt)>CritLength))        if (isDiscrete==0) % Data are continuous            R=cpc(Cumt); % putative inflection points; cpc is embedded local function            L=rrc(Cumt,R); % logit vector for continuous case; rrc is embedded local function                    else % data are discrete            R=cpd(Cumt); % putative inflection points; cpd is embedded local function            if test==1 % if binomial test is to be used                L=rrd(Cumt,R); % logit vector; rrd is embedded local function            else % if chisquare test is to be used                [L]=chi2logit(Cumt,R); % chi2logit is embedded local function            end  % of computing logit vector in discrete case        end  % of computing R & L for one pass              [Cumt,~,r]=trun(Cumt,R,L,Crit); %Cumt is the truncated cumulative             % record; r is the change point; r is empty if there is             % no significant change point; trun is embedded local function                 if (~isempty(r)) % if there is a change point, update change-point array             if isDiscrete==0 % In the continuous case, the row count goes in the                % y-column of the output array (the event count); in all other cases, it goes                % in the x column. In the continuous case, the x column                % contains the successive event times                CP(end+1,2)=CP(end,2)+r; % Add Cumt row for latest change point                % to last change point to get Cum row of latest change                % point.                 CP(end,1)=Cum(CP(end,2)); % Value of cumulative record at the                % change point            else % In the discrete case, the row data go in the first column of CP                     CP(end+1,1)=CP(end,1)+r; % Add Cumt row for latest change point                % to last change point to get Cum row of latest change point                CP(end,2)=Cum(CP(end,1)); % Value of cumulative record at the                % change point            end        end % of updating change-point array              end % of while loop for finding successive change points when the binomial test is used      end % of section that computes change-point array when binomial or chi square test is used  % Section for computing change-point array when K-S or t- test is used if (test==2) || (test==3)         NewData=Data; % Initializing for while loop. These vectors will        % be truncated as change points are found    CP=[0 0]; r=1; % Initializing for while loop        if test==2        CritLength=7; % K-S test is not valid when there        % are fewer than 4 data in either of the two samples    else        CritLength=2; % when t test is used there must be at least 3 data    end        while (~isempty(r)) && (length(NewData)>CritLength)                NewCum=cumsum(NewData);             if (isDiscrete==0) % Data are continuous            R=cpc(NewCum); % cpc is embedded function        else % Data are discrete            R=cpd(NewCum); % cpd is embedded function        end % computing R                if test==2 % if K-S test is to be used            [r]=ks(NewData,R,Crit); % r is the (significant) change point; if                % there is none, it's empty; ks is embedded function        else % if t test is to be used            [r] = cpt(NewData,R,Crit); % cpt is embedded function        end % of computing new change point        if ~isempty(r) % if there is a new change point, update change-point array         % and truncate NewData            if (isDiscrete==1) % Data are discrete, in which case,                % the row data go in the first column of CP                            CP(end+1,1)=CP(end,1)+r; % Add Cumt row for latest change point                % to last change point to get Cum row of latest change                % point                CP(end,2)=Cum(CP(end,1)); % Value of cumulative record at the                % change point                            else % Data are continuous, so the row count goes in the                % y-column of the output array (the event count)                CP(end+1,2)=CP(end,2)+r;                                CP(end,1)=Cum(CP(end,2));            end                         NewData=NewData(r+1:end); % Truncated data vector                     end % of updating change-point array & truncating            end % of while loop for computing CP array when K-S or t test are used    end % of section that computes CP array when K-S or t test are used% Adding final point to output arrayif isDiscrete==1         CP(end+1,1)=length(Cum); CP(end,2)=Cum(CP(end,1)); % last row of CP array     % gives coordinates of final point in cumulative record else % in continuous case, row count goes in y column     CP(end+1,2)=length(Cum); CP(end,1)=Cum(CP(end,2)); end % of adding final point% return% Computing SlopesS=slopes_local(CP);%Plottingif fig    figure    subplot(2,1,1)    if isDiscrete==0          PlotArray=ystep(Cum); % 2-column array for plotting cumulative record        % ystep is an embedded function    else        PlotArray=xstep(Cum); % xstep is an embedded function    end    plot(PlotArray(:,1),PlotArray(:,2),'k'); % cumulative record    hold on    plot(CP(:,1),CP(:,2),'ko') % change points superposed    if isDiscrete==0        xlabel('Time');ylabel('Number of Events')    else        xlabel('Trials');ylabel('Cumulative response measure')    end    subplot(2,1,2)    plot(S(:,1),S(:,2),'k')    if isDiscrete==0        xlabel('Time');ylabel('Average Rate = Events/(Unit Time)')    else        xlabel('Trials');ylabel('Average Response per Trial')    endendfunction R=cpc(Cum)%cpc finds putative change points in continuous-time cumulative records% It takes as input a vector of the cumulative interevent intervals% Syntax is  R=cpc(Cum)% The Nth row of Cum gives the interval from the onset of observation to% the Nth event. The putative change point corresponding to the Nth% event is the preceding event at which the deviation of the observed event count% from the expected event count is maximal. The expected event count% at any earlier event, n, is Cum(n), the interval up to the nth event,% divided by the average interevent interval over the range from n = 0 to n = N % The deviation from expectation is n - this expectation. R is the value% of n at which this deviation is maximalN=(1:length(Cum))'; % Event count vectorSlopes=N./Cum;	% Average slope up to given point in cumulative functionDg=flipud(cumsum(flipud(eye(length(Cum)))));% Mask with ones on and above diagonal & zeros belowDiagonal=Dg.*repmat(Slopes',length(Slopes),1);% Creates an array in which successive cols have successive slopes of the cumulative record.% The slope for a given col fills all the cells on and above the main diagonalPreds=repmat(Cum,1,length(Cum)).*Diagonal;% Creates diagonal array of the predicted numbers of events at each time in Cum	Obs=repmat(N,1,length(Cum)).*Dg; % Diagonal array with actual numbers of eventsDevs=abs(Obs-Preds); % Diagonal array of deviations from expectations[~,R]=max(Devs); % mx is a row vector listing the maximum in each col% R is a row vector specifying the row in which the max occursR=R'; % Converts R to col vectorfunction L=rrc(Cum,R)%RRC computes pseudologit vector for continuous random rate case% Syntax is L=rrc(Cum,R)% Cum is the cumulative interevent interval vector% R is the vector specifying the row number (hence, the event number) of the putative CP% L is the vector giving for each event the pseudologit--log[P/(1-P+p)]--% for the probability of observing n_a or fewer post CP events if lambda_a/lambda_b = 1% where lambda_a and lambda_b are the rates of event occurrence before and after% the putative change point; P is the probability of observing N-R or fewer% events after the putative change point; and p is the probability of% observing exactly N-R events after the putative change point.% Note that the numerator and denominator of the pseudologit are not complementary% probabilities, as they are in a true logit; they both include the probability of observing% exactly N-R events, where N is the total number of events at the moment of calculation.% The putative change point is the row (R=event number) at which% the difference between (N/Cum(N))*(Cum(R) and Cum(R) is maximal% N/Cum(N) is the slope of the cumulative record up to the Nth event% Cum(R) is the time up to the Rth event% A negative pseudologit means that n_a is less than expectedTa=Cum-Cum(R); % the interval elapsed since the putative change pointp=Ta./Cum;	% probability of any one event falling after the putative change pointN=(1:length(Cum))'; % event count vectorNa=N-R; % vector giving number of events since putative change pointPeqorl=binocdf(Na(2:end),N(2:end),p(2:end)); % Probability of observing Na or fewer events in the interval TaPeqorm=1-Peqorl+binopdf(Na(2:end),N(2:end),p(2:end));%Probability of observing Na or more events% in the interval Ta. Note that this probability overlaps the "complementary" probability;% both include the probability of observing exactly Na events.L=[0;log10(Peqorl.\Peqorm)]; % Vector of the pseudologitsfunction [Cumt,Lt,r]=trun(Cum,R,L,Crit)%TRUN truncates cumulative record at significant change points% Works for both cumulative responses vs trials and cumulative events vs time% that is, it works for both discrete and continuous cumulative records% Syntax is [Cumt Lt r]=trun(Cum,R,L,Crit)% All input arguments obligatory% Cum is cumulative vector (cumulative interevent intervals or cumulative responses)% R is putative change point vector% L is pseudologit vector, where logit is (approximately) the log of the odds that% there has been an CP;% Crit is decision criterion on logit;% Cumt is truncated cumulative record,% the record as it would be if observation began at time CP+ or after trial CP% Lt is the L vector truncated at Alert, which is the row at which an CP was detected% r is row at which it was truncated. All arguments are returned as empty% when there is no significant change pointLa=abs(L);Alert=find(La>Crit,1); % Finds first row where decision criterion is exceeded% If there is no such row, then Alert will be emptyif isempty(Alert)		Cumt=Cum; r=Alert; Lt=L;		return; % Returns the input Cum, input L & r = [] when there are no sig CPs	end;r=R(Alert); % The putative change point at the value of Cum that first yields significant logit.% This putative change point is always the number of an earlier event or trialI=[Cum(1);diff(Cum)]; % Interevent interval vector OR vector of responses on successive trialsCumt=cumsum(I(r+1:end)); % Truncated cumulative recordLt=L(1:Alert); % Truncated logit vectorfunction R=cpd(Cum)%cpd finds putative change points in discrete-time cumulative records% It takes as input a vector of the cumulative response counts (or measures)% at ends of successive trials% Syntax is R=cpd(Cum)% The Nth row of Cum gives the count (or cumulative measure) up to and including the Nth trial% The putative change point corresponding to the Nth trial is the% preceding trial at which the deviation of the observed count or measure% from the expected count or measure is maximal. The expected count or measure% at end of an earlier trial, n, is the average count or measure per trial% over the range from n = 0 to n = N, times n.% The deviation from expectation is Cum(n) - this expectation. R is the value% of n at which this deviation is maximalN=(1:length(Cum))'; % Trial count vectorSlopes=Cum./N;	% Average count or measure per trial for trials 1 to NDg=flipud(cumsum(flipud(eye(length(Cum)))));% Mask with ones on and above diagonal & zeros belowDiag=Dg.*repmat(Slopes',length(Slopes),1);% Creates an array in which successive cols have successive slopes of the cumulative record.% The slope for a given col fills all the cells on and above the main diagonalPreds=repmat(N,1,length(Cum)).*Diag;% Predicted (expected) cumulative values in a diagonal array	Obs=repmat(Cum,1,length(Cum)).*Dg; % Diagonal array of observed cumulationsDevs=abs(Obs-Preds); % Diagonal array of deviations from expectations[~,R]=max(Devs); % mx is a row vector listing the maximum in each col% R is a row vector specifying the row in which the max occursR=R'; % Converts R to col vectorfunction L=rrd(Cum,R)% RRD computes the pseudologit vector for the discrete random rate case,% Syntax is  L=rrd(Cum,R)% Cum is the cumulative response count% R is the trial number of the putative change point% % L is the vector giving for each trial the pseudologit--log[P/(1-P+p)]--% for the probability of observing n_a or fewer post-CP responses if lambda_a/lambda_b = 1% where lambda_a and lambda_b are the rates of responding before and after% the putative change point; P is the probability of observing Cum-Cum(R) or fewer% responses after the putative change point; and p is the probability of% observing exactly Cum-Cum(R) responses after the putative change point.% Note that the numerator and denominator of the pseudologit are not complementary% probabilities, as they are in a true logit; they both include the probability of observing% exactly Cum-Cum(R) post-CP responses,% where Cum is the cumulative number of responsess at the moment of calculation.% The putative change point is the row (R=trial number) at which% the difference between the observed and expected number of responses is maximal% Cum/N is the slope of the cumulative record up to N (i.e., the average response rate% up to the trial of calculation% (Cum/N)*R is the expected number of responses up to trial R; Cum(R) is the observed number.% A negative pseudologit means that n_a is less than expectedT=(1:length(Cum))'; % The trial count vectorTa=T-R; % the trials since the putative change pointp=Ta./T; % probability of any one response occuring during the trials since the putative CPNa=Cum-Cum(R); % number of responses since putative CPPeqorl=binocdf(Na(2:end),Cum(2:end),p(2:end)); % Probability of observing Na or fewer total responses on the trials since putative CPPeqorm=1-Peqorl+binopdf(Na(2:end),Cum(2:end),p(2:end));%Probability of observing Na or more% total responses on the trials since putative CP. Note that this probability overlaps% the "complementary" prob; both include the probability of observing exactly Na events.L=[0;log10(Peqorl./Peqorm)]; % Vector of the pseudologitsfunction [Lgt,Level,NV]=chi2logit(Cum,R)% Version 2 (uses Fisher exact when chi2 not valid). Returns (Lgt) the log of the odds against the null hypothesis that% the  percentages of 1's before and after the putative change points% do not differ. Also (optionally) the point (Level) beyond which the% Chi square test is valid (because no expectation < 5)% and (NV) the rows for which the chi square test cannot% validly be performed (because at least one cell has an expectation% less than 5). Syntax is [Lgt Level NV]=chi2logit(Cum,R).% Cum is the running sum of the number of 1's. R is the vector% of putative change points. Lgt is the logit vector, giving for each% trial the log of the odds against the null (no change) hypothesis as of% that trial. This version was modified in Oct or Nov 2003 so that it does the% Fisher exact test on those tables where the chi square is not valid.N(1,1,:)=(1:length(Cum))'; % Creates a 3 dimensional array with the levels% (3rd dimension nummbered in ascending sequence). The first two dimensions% are dummy dimensions to make this array the same dimensionality as the% ones it will be combined with. Conceptually, this is just a vector.% Column totals. These are the numbers of observations (sums of 0's & 1's)% before (1st column) and after (second column) the CP. Note that these are% three dimensional arrays, but the first (row) dimension is a singleton,% i.e., a dummy dimension, only 1 cell deep.Level1=find(Cum>6,1); % Finds the row (level of stacked 2x2 tables)% below which even the Fisher exact test should not be applied, because it% cannot yield a p value lower than .1 with fewer than 7 observations, and,% moreover, for fewer than 4 observations, fishexct.m returns p values% greater than 1.C(1,1,:)=R; % First column totals = numbers of observations up to and% including putative CPC(1,2,:)=N(1,1,:)-C(1,1,:); % Second column totals = # observations after CPRw(1,1,:)=Cum; % First row totals = total numbers of 1'sRw(2,1,:)=N(1,1,:)-Rw(1,1,:); % Second row totals = total numbers of 0'sSmallest=min(Rw).*min(C)./N; % The smallest expectation is the% smallest row total times the smallest column total, divided by NNV=find(Smallest<5); % Critical value for cell expectations is 5. NV is the% vector of rows whose contingency tables have a cell with less than the% critical valueLevel=max(NV); % The highest level at which the  smallest expectation is less than 5. % Chi square is not valid when smallest expectation less than 5.  % Constructing the three dimensional array of cell totals (rows by columns by levels). Each level% is a 2x2 table. The rows of the table are the% mutually exclusive and exhaustive outcomes (# of 1's in first row, # of% 0"s in second row). The columns of a level are before and after the% putative change point. Thus, at a given level, L, Cell(1,1,L) gives the% number of rewards on the given hole up to the putative change point;% Cell (2,1,L) gives the number of rewards on the other hole up to the% putative change point; Cell(2,1,L) gives the number of rewards on the% given hole after the putative change point; and Cell(2,2,L) gives the% nummber on the other hole after the putative change point. There are% as many levels as there are rows in the Cum vector, because the chi square test is% repeated for each successive entry.T(1,1,:)=Cum(R); % first cell of chi square table (# 1's up to R) T(1,2,:)=Cum-Cum(R); % # 1's after R  T(2,1,:)=C(1,1,:)-T(1,1,:); % Once the entries in the first row of the % 2x2 table have been filled in, the entries in the bottom row are % determined because the sum down the column must equal the column total. % Thus, the entry for the bottom row is the column total minus the entry % for the top row  T(2,2,:)=C(1,2,:)-T(1,2,:); % # 0's after R  Num=N(1,1,:).*(T(1,2,:).*T(2,1,:)-T(1,1,:).*T(2,2,:)).^2; % numerator of chi sq  Denom=Rw(1,1,:).*Rw(2,1,:).*C(1,1,:).*C(1,2,:); % denominator  ChiSq=squeeze(Num./Denom); % squeeze gets rid of dummy dimensions (those only 1 cell deep)  ChiSq(1:Level1)=1; % Sets chisquare equal 1 for all those initial rows where it is not valid for i=1:length(ChiSq)    p(i)=chi2cdf(ChiSq(i),1); % This is p of ChiSq smaller than is observed. The improbability    % of the null is 1-pendp=p';  for rw=1:length(NV); p(NV(rw))=fishexct(T(:,:,NV(rw))); end % Uses Fisher's exact test to compute % p's for the cases where chi square is not valid Lgt=log10(p./(1-p));Lgt(1:Level1)=0; % Zeros logit values for the initial string of observations within which% there are too few observations to do even Fisher's exact testfunction [r1,r2,L,t]=ks(Data,R,Crit)% KS computes the logit vector using the Kolmogorov-Smirnov test for% whether two distributions differ% The syntax is [r1,r2,L,t]=ks(Data,R,Crit)% Data is a column vector of successive measures (interevent intervals,% responses, poke durations, etc). NB, it is not the cumulative vector!% R is the vector of putative change points.% Crit is the decision criterion.% All arguments are obligatory.% L is the pseudologit vector for rows where the% approximation formula for the Kolmogorov-Smirnov p is valid.% Its final value is the first value to exceed the decision criterion% t is the col vector of rows for which L is defined% r1 is the change point row when the decision criterion is exceeded% r2 is the row at which the decision criterion is exceeded% If there are no testable rows or if the decision criterion is never% exceeded, the variables are returned emptyN=(1:length(Data))'; % Number of rows in Data vectorr1=[];r2=[];L=zeros(length(N),1); t=[]; % InitializingNa=N-R; % Col vector giving for each row in Data the number of rows%           after the putative change point. So R gives the number of%           rows before the change point and Na the number afterTest=find((Na.*R)./(Na+R)>=4); % For the approximation to the KS%           probability to be valid, the product of the two n's divided by%           the sum must be greater than or equal to 4. Test is the col%           vector of rows that satisfy this constraint--the row numbers(!),%           not the entries themselvesif isempty(Test) % There are no rows satisfying the constraint       return % Bail if there are no testable points   end;for T =1:length(Test) % Loop that steps through Data performing the KS test wherever    %   it is valid, until the resulting logit exceeds the decision    %   criterion        [~,P(T)]=kstest2(Data(1:R(Test(T))),Data(R(Test(T))+1:Test(T)),.05,-1);        L(T)=log10((1-P(T))/P(T));        t(T)=Test(T); % The row to which the latest value of L(T) "belongs"        if L(T)>Crit % Value of logit exceeds decision criterion                r2=Test(T); % the row (in Data) at which the criterion is exceeded        r1=R(Test(T)); % the change point  when the criterion is exceeded,                 L(T+1:end)=[]; % Drop rows of L after row in which decision criterion reached        break % Break out of loop when decision criterion exceeded            end % of if    end % of fort=t'; % Makes t a column vector, like Lfunction [CP,L,Var] = cpt(Data,R,Crit)% Uses t test to find first significant change point.% Syntax is [CP,L,Var] = cpt(Data,R,Crit). Data is the vector of trial by% trial measures or successive intervals. This test is appropriate if one% is looking for a change in the expectation of a renewal event-generating% process, where the interevent intervals are normally (rather than% exponentially) distributed. Also when trial measures are normally% distributed. R is the vector of putative change% points. Crit is the decision criterion, the value the logit must exceed% for the function to return a significant change point. CP is the% first significant change point. L is the logit vector up to and including% the row where the significance criterion (Crit) is exceeded. Var% indicates the different possibilities for the variance estimates from the% before and after data, to wit: Var==1 indicates that the estimates were% both nonzero and not significantly different; Var==0 indicates that one% of them was 0; Var==2 indicates that they were both nonzero and% significantly different. The function uses the equal variance version of% the t test in the Var=1 case (that is, it pools the variance% estimates); it uses the unequal variance version of the t test% in the second and third cases (Var = 0 0r 2). If there is no significant% change point, CP is returned empty    L(1:2,1)=0; r=3; Var=[0 0 0];% Initializing for while loop; r is the indexwhile abs(L(end))<Crit % loop that ends when critical L found or end of data reached        Vb=var(Data(1:R(r))); dfb=length(Data(1:R(r)))-1; % variance estimates    % and associated degrees of freedom for the data up to and including    % the putative change point        Va=var(Data(R(r)+1:r)); dfa=length(Data(R(r)+1:r))-1; % ditto for    % data after putative change point               if Vb+Va>0 % If #1: Is at least one estimate greater than zero?    % test cannot be run when there is no variance on either side of putative CP, for    % example, in the sequence 0 0 0 3 3 3.            if (min([Va;Vb])==0) % If #2: One estimate is zero, use unequal var t test                        if (dfa*dfb)==0;r=r+1;continue;end; % Unequal variance version of t            % test requires that both df's be greater than 0, so when that            % condition is not satisfied, go on to next iteration                        [~,pb]=ttest2(Data(1:R(r)),Data(R(r)+1:r),.05,'right','unequal');            % The .05 is a nominal significance level; it is there because            % a third argument is required if there is to be a fourth. The            % rest of the program uses only pb, not H.                        Var(end+1,:)=[r R(r) 0];                    elseif (fcdf(Va/Vb,dfa,dfb)>.95) || (fcdf(Va/Vb,dfa,dfb)<.05) % The            % two non-zero variance estimates are significantly unequal            % (also use the unequal variance version of the t test). Note            % that for both variance estimates to be nonzero, both df's            % must also be nonzero                        [~,pb]=ttest2(Data(1:R(r)),Data(R(r)+1:r),.05,'right','unequal');                            Var(end+1,:)=[r R(r) 2]; % variance estimates both non-zero and significantly different                    else % variances both nonzero and not significantly unequal                        % Var=1; % t test based on a single pooled variance estimate                        [~,pb]=ttest2(Data(1:R(r)),Data(R(r)+1:r),.05,'right'); % equal variance version                    end % of if-elseif-else (If #2)                L(r)=log10(pb/(1-pb)); %Latest logit                            else L(r)=0; % This else goes with If # 1 (are both variance estimates 0?)             end % of If #1, which computes indvidual L values         r=r+1; % Incrementing latest row for next iteration        if r>length(Data); break;end % terminate while loop if end of data reached            end % of while loop; looping ceases either when end of data reached or when logit% exceeds decision criterion        if abs(L(end))>Crit;        CP=R(r-1);    else    CP=[];endif (var(Data)>0) && (Va==0) && (Vb==0)        disp('Variance estimates up to and after change point both zero')    endfunction CR=ystep(Cum)% YSTEP creates two-column array for plotting cumulative record when all y increments are 1% and x increments are real valued (usually, interevent intervals). Syntax% CR = ystep(Cum). Cum is a vector of cumulative interevent intervals.% The entry in the nth row of Cum is the interval from the onset of observation% to the occurrence of the nth eventN=(1:length(Cum))'; % Event-count vectorCumd=sort(repmat(Cum,2,1));% makes doublet vector, which has two successive identical values for each single value of CumNd=sort(repmat(N,2,1)); % doublet vector for event countsCumd=[0;Cumd]; % Puts t=0 at beginning of doublet time vectorNd=[0;0;Nd(1:end-1)];% Count = 0 at t=0 and also at -t_1, the time immediately before the first event% Doublet count at end of record is droppedCR=[Cumd Nd]; % Data required to make a step-plot cumulative record% with time (Cumd) of x axis and event count (Nd) on y axisfunction CR=xstep(Cum)%XSTEP creates two-column array for plotting cumulative record when x increment always 1% Syntax is CR=xstep(Cum)% Cum is a vector of cumulative response counts or measures over a sequence of trials% The entry in the nth row of Cum is the total count or measure as of end% of nth trial. This version of xstep corrects a defect in the original% version, which did not deal properly with cumulative records containing% negative valuesN=repmat((1:length(Cum)),2,1); % Duplicated trial-count vector in 2xN arrayNd=N(1:end)'; % When you single-index an array, the cells are indexed% from top to bottom of each column and then left to right for successive% columns. In this case, the result, after transposition, is a column% vector with each entry trial count a doublet entryCumd=repmat(Cum,1,2)'; % Duplicates and transposes Cum to make 2xN array with% Cum in both rowsCumd=Cumd(1:end)'; % Column vector with doublet entries for CumNd=[0;Nd]; % 0th trial is trial before observation begins; origin of x axisCumd=[0;0;Cumd(1:end-1)]; % There are 0 (observed) responses as of 0th trial% and also at beginning of 1st trial. Cum(1) gives count as of end of 1st trial.% Doublet of final cumulation is droppedCR=[Nd Cumd]; % Data required to make a step-plot cumulative record% with trials (Nd) on x axis and cumulation (Cumd) on y axisfunction S=slopes_local(CP)% calculates x and y values for step plot of slopes% Syntax S=slopes(CP)% CP is a 2 column array, whose 1st col gives the row numbers of the% successive significant change points and whose 2nd col gives% the value of the cumulative count at that row number% In other words, the input array gives the coordinates of the significant% change points% The 1st col of S contains the trial numbers at which there are% significant changes in slopes.% The 2nd col of S gives the slopes.% In both cols, values are duplicated so as to make steps in the plotted% function at the trials where there are significant change pointsif size(CP,1)<2        S=[0 0;0 CP(2)/CP(1);CP(1) CP(2)/CP(1)];    else    Deltas=[CP(1,:);diff(CP)]; % Delta trials (btwn Infl Pts) & delta Counts    Slopes=Deltas(:,2)./Deltas(:,1); % Successive slopes of the cum count record    DblT=[0;sort(repmat(CP(:,1),2,1))]; % Trial (x) - axis doublet values    DblT(end)=[]; % Deletes 2nd half of last doublet trial    Slopes1(1:2:2*length(Slopes))=Slopes;    Slopes1(2:2:2*length(Slopes))=Slopes; % Doublet slope values    S=[DblT Slopes1']; % Returns array for plotting    end